/*
 * Copyright (C) 2025 Andr√°s Oravecz and the contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package hu.oandras.kJarify

import hu.oandras.kJarify.dex.DexProcessor
import hu.oandras.kJarify.dex.DexReader
import hu.oandras.kJarify.jvm.optimization.OptimizationOptions
import hu.oandras.kJarify.streams.JarOutputStream
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import org.apache.commons.cli.CommandLine
import org.apache.commons.cli.DefaultParser
import org.apache.commons.cli.Options
import java.io.IOException
import java.text.ParseException
import java.util.Map

fun main(args: Array<String>): Unit = runBlocking {
    mainImpl(args)
}

internal suspend fun mainImpl(args: Array<String>) {
    val options = createCommandLineOptions()

    val cmd: CommandLine = try {
        DefaultParser().parse(options, args)
    } catch (_: ParseException) {
        println("Failed to parse command line properties")
        return
    }

    val inputFile = cmd.args.firstOrNull() ?: run {
        println("Missing input file")
        return
    }

    val outputName: String = cmd.getOptionValue(
        "o",
    ) ?: run {
        inputFile.substring(inputFile.lastIndexOf('/') + 1, inputFile.lastIndexOf('.')) + "-kEnJarify.jar"
    }

    val start = System.currentTimeMillis()

    try {
        val jarWriter = JarOutputStream(
            path = outputName,
            force = cmd.hasOption("f"),
        )

        val dexReader = if (inputFile.endsWith(".apk", ignoreCase = true)) {
            DexReader.ApkDexFileReader
        } else {
            DexReader.SimpleDexFileReader
        }

        val dexDataList = dexReader.read(filePath = inputFile)

        val callback = object : DexProcessor.SysOutProcessStatusCallBack() {
            override suspend fun suspendOnClassTranslated(unicodeName: String, classData: ByteArray) {
                jarWriter.writeClass(unicodeName, classData)
            }
        }

        val processor = DexProcessor(
            optimizationOptions = OptimizationOptions(options),
            coroutineDispatcher = Dispatchers.Default,
            callback = callback,
        )
        processor.suspendProcess(dexDataList)

        printErrors(processor.errors)

        println("Output written to $outputName")

        val end = System.currentTimeMillis()
        val diff = end - start
        println("Processed under $diff ms")
    } catch (_: IOException) {
        println("Error, output file already exists and --force was not specified.")
        println("To overwrite the output file, pass -f or --force.")
    }
}

private fun printErrors(errors: LinkedHashMap<String, String>) {
    if (errors.isEmpty()) {
        return
    }

    println("Errors: ")
    errors.entries.stream().sorted(Map.Entry.comparingByKey()).forEach { entry ->
        println("${entry.key} ${entry.value}")
    }
}

private fun createCommandLineOptions(): Options {
    val options = Options()
    options.addOption("o", "output", true, "Output .jar file. Default is [input-filename]-kEnJarify.jar.")
    options.addOption(
        "f",
        "force",
        false,
        "Force overwrite. If output file already exists, this option is required to overwrite."
    )
    options.addOption(
        "fast",
        false,
        "Speed up translation at the expense of generated bytecode being less readable."
    )
    return options
}

private fun OptimizationOptions(options: Options): OptimizationOptions {
    return when {
        options.hasOption("fast") -> {
            OptimizationOptions.NONE
        }

        else -> {
            OptimizationOptions.PRETTY
        }
    }
}
